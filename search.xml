<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>硬币悖论</title>
    <url>/posts/b04da4d7/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个硬币围绕另一个硬币无滑动的滚动，从上方滚到下方时到底旋转了几圈。</p><p>滚过的路径只有半个圆周，但是外面的硬币却旋转了一圈。</p><p><img src="/images/lazy.gif" data-original="https://i.loli.net/2020/10/24/yvCpY8HJkFucwqe.png" alt="image.png"></p><h1 id="定量研究"><a href="#定量研究" class="headerlink" title="定量研究"></a>定量研究</h1><h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>质点在以某点为圆心半径为r的圆周上运动，即质点运动时其轨迹是圆周的运动叫“圆周运动”。它是一种最常见的曲线运动。例如电动机转子、车轮、皮带轮等都作圆周运动。</p></blockquote><p><img src="/images/lazy.gif" data-original="https://i.loli.net/2020/10/24/MRH8OAEmcqT7eJ5.gif" alt="timg-1.gif"></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>匀速圆周运动的特点：轨迹是圆，角速度，周期，线速度的大小(注：因为线速度是矢量,”线速度”大小是不变的，而方向时时在变化)和向心加速度的大小不变，且向心加速度方向总是指向圆心。</p><p>线速度定义：质点沿圆周运动通过的弧长<script type="math/tex">\Delta {L}</script>与所用的时间<script type="math/tex">\Delta {t}</script>的比值叫做线速度，或者角速度与半径的乘积。<script type="math/tex">v=\frac{\Delta {L}}{\Delta {t}}</script></p><p>线速度的物理意义：描述质点沿圆周运动的快慢，是矢量。</p><p>角速度的定义:半径转过的弧度（弧度制:<script type="math/tex">360^{\circ} = 2\pi</script>）与所用时间<script type="math/tex">t</script>的比值。（匀速圆周运动中角速度恒定）<script type="math/tex">\omega =\frac{\Delta \theta }{\Delta t}</script></p><p>周期的定义：作匀速圆周运动的物体,转过一周所用的时间。<script type="math/tex">T=\frac{2\pi r}{v}</script></p><p>频率：单位时间内完成圆周运动的圈数。<script type="math/tex">f=\frac{1}{T}</script></p><p>转速的定义：作匀速圆周运动的物体，单位时间所转过的圈数。<script type="math/tex">n=\frac{N}{t}</script></p><p>各个物理量之间的公式关系如下：</p><script type="math/tex;mode=display">\left\{\begin{matrix}
v=\frac{2\pi r}{T} =2\pi fr=2\pi nr
\\ \omega =\frac{2\pi }{T} =2\pi f=2\pi n
\\ v=\omega r
\\ T=\frac{1}{f} 
\end{matrix}\right.</script><h3 id="速度的叠加"><a href="#速度的叠加" class="headerlink" title="速度的叠加"></a>速度的叠加</h3><p><img src="/images/lazy.gif" data-original="https://i.loli.net/2020/10/24/gfWP6DqNs3HjGIJ.png" alt="image.png"></p><p>图中贴着地面的点(A点),一方面跟着圆心走速度为<script type="math/tex">v_0</script>,另一方面还有一个向后转动的速度为<script type="math/tex">\omega r</script>,所以这个点的速度为<script type="math/tex">v_0</script>和<script type="math/tex">\omega r</script>做差,这一时刻A点为瞬心(即速度等于地面的速度为零)</p><p>所以<script type="math/tex">v_0-\omega r=0</script></p><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><p><img src="/images/lazy.gif" data-original="https://i.loli.net/2020/10/24/ZD2lENxvSF3RUcA.png" alt="image.png"></p><p>如图所示圆<script type="math/tex">O_2</script>不动,因为圆<script type="math/tex">O_1</script>在转动,所以连线<script type="math/tex">O_1 O_2</script>也在转动,设角速度为<script type="math/tex">\omega_1</script>,同时设<script type="math/tex">O_1 O_2</script>为<script type="math/tex">l_1</script>,<script type="math/tex">O_1</script>与两圆的接触点<script type="math/tex">A</script>的距离为<script type="math/tex">l_2</script>,圆<script type="math/tex">O_1</script>绕<script type="math/tex">l_2</script>旋转的角速度为<script type="math/tex">\omega _2</script>.</p><p>所以<script type="math/tex">O_1</script>点有一个速度为<script type="math/tex">v_1=\omega_1 l_1</script>,瞬心<script type="math/tex">A</script>点有一个向前速度<script type="math/tex">v_1'=v_1=\omega_1 l_1</script>,和一个向后转动的速度为<script type="math/tex">\omega_2 l_2</script>.</p><p>同时因为<script type="math/tex">A</script>点为瞬心,所以<script type="math/tex">v_A=\omega_1 l_1-\omega_2 l_2</script>=0</p><p>所以<script type="math/tex">\omega_1 l_1=\omega_2 l_2</script>,设连线转动角度(公转角度)为<script type="math/tex">\theta _1=\omega_1 t</script>,另一圆转过的角度(自转角度)为<script type="math/tex">\theta _2=\omega_2 t</script></p><p>由上得</p><script type="math/tex;mode=display">\frac{\theta _1}{\theta _2}=\frac{\omega_1 t}{\omega_2 t}=\frac{\omega_1}{\omega_2}=\frac{l_2}{l_1}</script><p>因为本题中<script type="math/tex">l_1=2 l_2</script>,所以<script type="math/tex">2\theta _1=\theta _2</script>,即滚过的路径只有半个圆周，但是外面的硬币却旋转了一圈。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>当一个圆绕着另一个圆无滑动滚动时</p><script type="math/tex;mode=display">\frac{\theta _1}{\theta _2}=\frac{l_2}{l_1}</script><p>(公转角度)<script type="math/tex">\theta _1</script>(自转角度)<script type="math/tex">\theta _2</script></p><p>(两圆心连线)<script type="math/tex">l1</script>(旋转圆半径)<script type="math/tex">l_2</script></p></blockquote>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习</title>
    <url>/posts/1879f8e5/</url>
    <content><![CDATA[<h3 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- DOCTYPE 告诉浏览器我们要用什么规范 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 浏览器默认html 不加也没问题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- html 总标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- head 网页头部 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- body 网页主体 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个网页只有一个 head , body 标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- title 网络标题(选项卡) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- meta描述性标签,它用来描述网站的一些信息 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- meta通常作SEO--搜索引擎优化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mate</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- charset编码类型 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mate</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">contect</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 关键词 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mate</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">contect</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 描述 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网页基本标签"><a href="#网页基本标签" class="headerlink" title="网页基本标签"></a>网页基本标签</h3>]]></content>
  </entry>
  <entry>
    <title>对称点坐标</title>
    <url>/posts/e21acd07/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>​ 在平面直角坐标系中,有一条直线<script type="math/tex">l: Ax+By+C=0</script>,(注:方程<script type="math/tex">Ax+By+C=0</script>和解析式<script type="math/tex">y=- \frac{A}{B} x-\frac{C}{B}</script>在<script type="math/tex">B\ne 0</script>时等价 )和一给定点<script type="math/tex">P(\alpha,\beta )</script>,求<script type="math/tex">P</script>点关于直线<script type="math/tex">l</script>的对称点的坐标</p><p><img src="/images/lazy.gif" data-original="https://s1.ax1x.com/2020/07/30/auHbKH.png" style="zoom:15%"></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>​ 作<script type="math/tex">P</script>点关于<script type="math/tex">l</script>的对称点<script type="math/tex">P'</script>,并过<script type="math/tex">PP'</script>点作直线<script type="math/tex">l_{2}</script>,如下图:</p><p><img src="/images/lazy.gif" data-original="https://s1.ax1x.com/2020/08/01/aGm0nP.png" style="zoom:15%"></p><p>​ 可知直线<script type="math/tex">l_{2}</script>垂直平分<script type="math/tex">l</script>,令<script type="math/tex">l_{2}</script>交<script type="math/tex">l</script>于<script type="math/tex">M</script>,只要计算出<script type="math/tex">M</script>点的坐标即可通过<span id="inline-blue">中点坐标公式</span>计算出<script type="math/tex">P'</script>的坐标</p><blockquote><p><strong>中点坐标公式</strong></p><p>若<script type="math/tex">M</script>是<script type="math/tex">P</script>与<script type="math/tex">P'</script>的中点,则<script type="math/tex">M</script>点满足:</p><script type="math/tex;mode=display">M=\frac{P+P'}{2}</script><p>此式中的字母表示该点的相应坐标(或者说表示从原点到该点的向量),此式在任意维度的坐标系中都成立.</p></blockquote><p>​ 我们知道互相垂直的两条直线的斜率互为负倒数,所以由<script type="math/tex">l</script>的斜率为<script type="math/tex">-\frac{A}{B}</script>,可以知道<script type="math/tex">l_{2}</script>的斜率<script type="math/tex">k_{PP'}= \frac{B}{A}</script></p><p>​ 所以<script type="math/tex">l_{2}</script>的点斜式为<script type="math/tex">l_{2} :y-B=\frac{B}{A}(x-\alpha )</script>,把点斜式化为一般式并与<script type="math/tex">l</script>联立得:</p><script type="math/tex;mode=display">\left\{\begin{matrix} 
  Bx-Ay+a +(A\beta -B\alpha )=0 \\  
  Ax+By+C=0 
\end{matrix}\right.</script><p>​ 解这个方程组,结果即为<script type="math/tex">M</script>的坐标.</p><p>方程组的解为:</p><script type="math/tex;mode=display">x=\frac{B^{2}\alpha -AC-AB\beta }{A^{2}+B^{2}}
y=\frac{A^{2}\beta-BC-AB\alpha }{A^{2}+B^{2}}</script><p>则<script type="math/tex">M</script>点的坐标为:</p><script type="math/tex;mode=display">M(\frac{B^{2}\alpha -AC-AB\beta }{A^{2}+B^{2}}
,\frac{A^{2}\beta-BC-AB\alpha }{A^{2}+B^{2}}  )</script><p>带入中点坐标公式,得<script type="math/tex">P'</script>的坐标为:</p><script type="math/tex;mode=display">P'(2x_{M}-\alpha,2y_{M}-\beta)</script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><span id="inline-purple">垂足坐标公式</span></p><script type="math/tex;mode=display">M(\frac{B^{2}\alpha -AC-AB\beta }{A^{2}+B^{2}}
,\frac{A^{2}\beta-BC-AB\alpha }{A^{2}+B^{2}}  )</script><p><span id="inline-purple">对称点坐标公式</span></p><script type="math/tex;mode=display">P'(2x_{M}-\alpha,2y_{M}-\beta)</script></blockquote>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
      </tags>
  </entry>
  <entry>
    <title>STL选讲</title>
    <url>/posts/a220/</url>
    <content><![CDATA[<h3 id="STL是什么"><a href="#STL是什么" class="headerlink" title="STL是什么"></a>STL是什么</h3><p>STL是建立在模板函数和类模板基础之上的功能强大的库，包括：<br>—— 1）常用算法函数（如统计、排序、查找等）<br>—— 2）容器</p><p>​ 容器：存放数据的数据结构，例如数组、队列、栈、链表、树、图等，分为：<br>​ ——顺序容器：是指数据逻辑上、物理上都是按顺序存放的。</p><p>​ 常见的有：vector、queue、stack、deque。</p><p>​ ——关联容器：存放的数据逻辑上有一定关联，但不一定是按顺序存放的</p><p>​ 常见的有set、multiset、map、multimap</p><p>​ 迭代器(iterator):类似于C++中的指针，你可以把它看作是容器的数据存取员，通过它可以依次存取容器中的元素。不同的容器需要不同的迭代器，但这些迭代器的使用方法却类似。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="定义及简单变量类型数组排序"><a href="#定义及简单变量类型数组排序" class="headerlink" title="定义及简单变量类型数组排序"></a>定义及简单变量类型数组排序</h4><p>​ 我们学过选择排序、冒泡排序、插入排序等各种排序算法，其实STL给我们提 供了排序函数sort，我们可以直接使用它！例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],n; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i]; <span class="comment">//需要排序，可以直接调用STL排序函数 </span></span><br><span class="line">sort(a,a+n); <span class="comment">//将a数组下标[0,n)区间元素（左闭右开）排序，默认按从小到大顺序排列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure><p>​ sort是STL里的一个排序函数，包含在<algorithm>头文件中，它是利用快速 排序算法实现并进行优化的，具有非常高的效率，其时间复杂度为O(nlogn)</algorithm></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line"><span class="comment">//greater&lt;int&gt;()表示C++内置类型从大到小排序，尖括号里面int表示数组元素的数据类型</span></span><br><span class="line"><span class="comment">//如果是其他类型，就写相应的变量类型,如double等</span></span><br><span class="line"><span class="comment">//相对应还有less&lt;int&gt;()表示从小到大排序，这是系统默认的，可以省略。同样也可以使用函数来代替</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;<span class="comment">//降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(x,x+n,cmp);</span><br></pre></td></tr></table></figure><h4 id="sort对结构体排序"><a href="#sort对结构体排序" class="headerlink" title="sort对结构体排序"></a>sort对结构体排序</h4><p>​ sort除了对简单变量类型数组进行排序外，还可以对自定义的结构体数组进行排序。</p><p>​ 只是要提供结构体比较大小的函数，因为C++不知道自定义的结构体变量 谁大谁小。我们可以通过在结构体内添加比较大小的函数来实现！</p><h5 id="结构体成员函数介绍"><a href="#结构体成员函数介绍" class="headerlink" title="结构体成员函数介绍"></a>结构体成员函数介绍</h5><p>​ 结构体内其实除了定义“成员变量” ，将这些成员变量组合在一起之外，它的功 能非常强大，还可以在结构体内定义函数，我们称其为“成员函数”。</p><p>​ 成员函数主要完成跟结构体相关的功能，它可以直接调用结构体的成员变量，还 可以通过形参接受调用者传递进来的参数。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="built_in">string</span> Name; </span><br><span class="line">    <span class="keyword">int</span> Chinese,Math,English,sum; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span></span>&#123; </span><br><span class="line">        sum=Chinese+Math+English; </span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Student stu; </span><br><span class="line">    stu.Chinese=<span class="number">120</span>; </span><br><span class="line">    stu.Math=<span class="number">130</span>; </span><br><span class="line">    stu.English=<span class="number">90</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu.GetSum()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;输出 <span class="number">340</span></span><br></pre></td></tr></table></figure><h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p>​ 为了完成结构体比较大小的功能，我们可以在结构体里面定义一个比较大小的函数 。因为STL提供的算法函数、容器一般是调用小于运算符比较大小，所以我们这里重载 小于运算符，这样结构体就可以直接用小于运算符比较大小了。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; <span class="comment">//重载&lt;运算符 </span></span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//operator	相当于函数名，固定格式，照样子写即可</span></span><br><span class="line"><span class="comment">//const &amp;a	表示形参是常变量，函数中不允许修改形参</span></span><br><span class="line"><span class="comment">//后一个const	表示该函数是常函数，不允 许修改结构体成员变量的值</span></span><br></pre></td></tr></table></figure><h5 id="运算符重载函数的调用"><a href="#运算符重载函数的调用" class="headerlink" title="运算符重载函数的调用"></a>运算符重载函数的调用</h5><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...<span class="comment">//结构体与上文一样</span></span><br><span class="line"></span><br><span class="line">node a,b; </span><br><span class="line">a.x=<span class="number">12</span>;</span><br><span class="line">a.y=<span class="number">3</span>; </span><br><span class="line">b.x=<span class="number">8</span>;</span><br><span class="line">b.y=<span class="number">9</span>; </span><br><span class="line"><span class="keyword">if</span>(a&lt;b)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&lt;b"</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&gt;=b"</span>; </span><br><span class="line">&gt;&gt;输出 <span class="string">"a&gt;=b"</span></span><br></pre></td></tr></table></figure><p>​ 重载运算符我们可以把它看作是一类特殊的成员函数,a&lt;b本质是a.operator&lt;(b)，这里小于运算符是a的成员函数。所以重载运算符时传递的参数 只有一个。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//从小到大排</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">node p;</span><br><span class="line">sort(p,p+n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样也可以写函数排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">sort(p, p+n, cmp);</span><br></pre></td></tr></table></figure><p>补充: 初始化成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">double</span> x,y; </span><br><span class="line">    node(<span class="keyword">int</span> _x=<span class="number">0</span>,<span class="keyword">int</span> _y=<span class="number">0</span>):x(_x),y(_y)&#123;&#125; <span class="comment">//构造函数，完成成员变量初始化 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h4><p>​ vector是一种顺序容器，可以把它看作数组，是长度可变的动态数组。它的 储存空间根据存入数据多少自动分配，包含在<vector>头文件中。</vector></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;a; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;a; <span class="built_in">vector</span>&lt;Node&gt;a;<span class="comment">//Node为自定义的结构体 </span></span><br><span class="line"><span class="comment">//定义时初始化： </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);<span class="comment">//定义初始大小为10个元素的vector，初始值为0 </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>,<span class="number">2</span>);<span class="comment">//定义时给定大小为10，每个元素初始化为2 </span></span><br><span class="line"><span class="comment">//定义时用数组初始化： </span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">32</span>&#125;; 		</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b+<span class="number">1</span>,b+<span class="number">8</span>);<span class="comment">//用数组初始化，参数为迭代器，数组元素就是其地址 </span></span><br><span class="line"><span class="comment">//vector数组： </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">100</span>];<span class="comment">//vector数组，相当于二维数组 </span></span><br><span class="line"><span class="comment">//特别注意：</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>)和<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">10</span>]的区别</span><br></pre></td></tr></table></figure><h4 id="vector的引用"><a href="#vector的引用" class="headerlink" title="vector的引用"></a>vector的引用</h4><h5 id="下标-访问"><a href="#下标-访问" class="headerlink" title="下标[]访问"></a>下标[]访问</h5><p>略</p><h5 id="迭代器访问"><a href="#迭代器访问" class="headerlink" title="迭代器访问"></a>迭代器访问</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ::iterator it;  <span class="comment">//定义一个可以访问整型的vector的迭代器。 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a; </span><br><span class="line">............................. </span><br><span class="line"><span class="keyword">for</span>( it=a.<span class="built_in">begin</span>(); it!=a.<span class="built_in">end</span>();  it++ ) 		<span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure><p>​ a.begin()返回指向第一个元素的迭代器；a.end()返回指向最后一个元素 下一个元素位置的迭代器（左闭右开）；<br>​ it!=a.end(); 为结束条件，迭代器一般不比较大小，关联容器的迭代器不 能比较大小，只能判断是否相等；迭代器相当于指针，对于简单变量类型 *it就是 迭代器指向的数据元素的值。</p><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ol><li>push_back() 在vector的最后添加一个数据元素，复杂度O(1)</li><li>pop_back() 删除最后一个数据元素.复杂度O(1)</li><li>begin () 返回指向容器第一个元素的迭代器 .例如：it=a.begin();</li><li>end () 返回指向容器尾端的迭代器.例如：it=a.end();</li><li>size () 返回vector中数据元素的个数, 复杂度O(1).<br>例如：for(int i=0; i&lt;a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;” “;</li><li>resize (n) 重设容器数据元素为n个，它改变size()的返回值.如果n大于当前元素个数，则新增元素用默认值初始化，已有的元素不受影响. 如果n比当前数据元素个数小，则多余的舍弃，仅改变size()返回值</li><li>erase 删除;可以删除单个数据元素，也可以删除一个左闭右开区间内的元素<br>例如：c.erase (pos); //删除迭代器pos指向位置的元素 c.erase(bg,ed); // 删除迭代器[bg,ed)区间的数据</li><li>clear () 清空当前的vector，将size()归零，复杂度O(1).</li><li>rbegin() 返回指向最后一个元素的迭代器，用于逆向访问容器，这时要定义逆向迭代器，例如：vector<int>::reverse_iterator it;</int></li><li>rend() 返回指向第一个元素前一个位置的迭代器，逆向访问的结束位置</li><li>empty() 判断容器是否为空,若为空返回true，否则返回false</li><li>insert () 插入一个元素。 vector采用分块储存技术，时间复杂度O(log(size())<br>例如：c.insert(pos,elem); // 在迭代器pos指向元素前面插入elem.<br>c.insert(pos,ncount,elem);//在迭代器pos前插入ncount个elem<br>c.insert(pos,first,end);//在迭代器pos前插入区间[first,end)的元素，first和end也是迭代器，表示的区间是左闭右开。</li></ol>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>整除</title>
    <url>/posts/62599/</url>
    <content><![CDATA[<h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><h4 id="整除的定义"><a href="#整除的定义" class="headerlink" title="整除的定义"></a>整除的定义</h4><p>​ 对任给的两个整数<script type="math/tex">a,b(a\ne 0)</script>,如果存在整数<script type="math/tex">q</script>,使得<script type="math/tex">b=aq</script>,那么称<script type="math/tex">b</script>能被<script type="math/tex">a</script>整除,(或称<script type="math/tex">a</script>能整除<script type="math/tex">b</script>),记作<script type="math/tex">a\mid b</script>.否则,称<script type="math/tex">b</script>不能被<script type="math/tex">a</script>整除,记作<script type="math/tex">a \nmid b</script></p><p>​ 如果<script type="math/tex">a\mid b</script>,那么称<script type="math/tex">a</script>为<script type="math/tex">b</script>的因数,<script type="math/tex">b</script>为<script type="math/tex">a</script>的倍数.</p><h4 id="整除的基本性质"><a href="#整除的基本性质" class="headerlink" title="整除的基本性质"></a>整除的基本性质</h4><ul><li><p>​ 若<script type="math/tex">a\mid b,b\mid c</script>,那么<script type="math/tex">a\mid c</script>.这表明整除具有传递性.</p></li><li><p>​ 如果<script type="math/tex">a\mid b</script>,那么<script type="math/tex">a\mid (-b)</script>,反过来也成立;进一步,如果<script type="math/tex">a\mid b</script>,那么<script type="math/tex">(-a)\mid b</script>,反过来也成立.</p><p>​ 因此,我们经常只讨论正整数之间的整除关系.</p></li><li><p>​ 若<script type="math/tex">a\mid b,a\mid c</script>,则对任意整数<script type="math/tex">x,y</script>,都有<script type="math/tex">a\mid bx+cy</script>.(即<script type="math/tex">a</script>能整除<script type="math/tex">b,c</script>的任意一个”线性组合”)</p></li></ul><h4 id="能被整除的数的特征"><a href="#能被整除的数的特征" class="headerlink" title="能被整除的数的特征"></a>能被整除的数的特征</h4><ol><li>1与0的特性<br>1是任何整数的约数，即对于任何整数a，总有1|a.<br>0是任何非零整数的倍数，a≠0,a为整数，则a|0.</li><li>能被2整除的数的特征<br>若一个整数的末位是0、2、4、6或8，则这个数能被2整除.</li><li>能被3整除的数的特征<br>1.若一个整数的数字和能被3整除，则这个整数能被3整除;<br>2.由相同的数字组成的三位数、六位数、九位数……这些数字能被3整除.如111被3整除.</li><li>能被4整除的数的特征<br>若一个整数的末尾两位数能被4整除，则这个数能被4整除.</li><li>能被5整除的数的特征<br>若一个整数的末位是0或5，则这个数能被5整除</li><li>能被11整除的数的特征<br>若一个整数的奇位数字之和与偶位数字之和的差能被11整除，则这个数能被11整除.</li></ol>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>整除</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<script src="/live2d-widget/autoload.js"></script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类知乎卡片超链接测试"><a href="#类知乎卡片超链接测试" class="headerlink" title="类知乎卡片超链接测试"></a>类知乎卡片超链接测试</h4><p><a href="/photos/" class="LinkCard">我的相册——时光留影</a></p><hr><h4 id="APlayer音乐播放器测试"><a href="#APlayer音乐播放器测试" class="headerlink" title="APlayer音乐播放器测试"></a>APlayer音乐播放器测试</h4><p><link rel="stylesheet" href="/dist/APlayer.min.css"></p><p></p><div id="aplayer"></div><p></p><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><hr><h4 id="DPlayer视频播放器测试"><a href="#DPlayer视频播放器测试" class="headerlink" title="DPlayer视频播放器测试"></a>DPlayer视频播放器测试</h4><p></p><div id="dplayer"></div><p></p><script src="/dist/DPlayer.min.js"></script><script type="text/javascript" src="/dist/video.js"></script><hr><h4 id="B站视频播放器测试"><a href="#B站视频播放器测试" class="headerlink" title="B站视频播放器测试"></a>B站视频播放器测试</h4><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=455914516&bvid=BV1Z5411p7Ct&cid=204031142&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><hr><h4 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h4><p><span id="inline-blue">站点配置文件</span><br><span id="inline-purple">主题配置文件</span><br><span id="inline-yellow">站点配置文件</span><br><span id="inline-green">主题配置文件</span></p><hr><h4 id="下载样式"><a href="#下载样式" class="headerlink" title="下载样式"></a>下载样式</h4><p><a id="download" href="https://git-scm.com/download/win" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span></a></p><hr><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><div class="note default"><p>default 提示块标签</p></div><div class="note primary"><p>primary 提示块标签</p></div><div class="note success"><p>success 提示块标签</p></div><div class="note info"><p>info 提示块标签</p></div><div class="note warning"><p>warning 提示块标签</p></div><div class="note danger"><p>danger 提示块标签</p></div><hr><h4 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h4><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong> 名字为A</p></div></div></div><hr><h4 id="地球"><a href="#地球" class="headerlink" title="地球"></a>地球</h4><script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5xgme3vd9ru&amp;m=6&amp;c=007eff&amp;cr1=ffffff&amp;f=arial&amp;l=33" async></script><hr><h4 id="Folding容器"><a href="#Folding容器" class="headerlink" title="Folding容器"></a>Folding容器</h4><div class="tabs" id="folding"><ul class="nav-tabs"><li class="tab active"><a href="#folding-1">语法格式</a></li><li class="tab"><a href="#folding-2">示例写法</a></li><li class="tab"><a href="#folding-3">示例效果</a></li></ul><div class="tab-content"><div class="tab-pane active" id="folding-1"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/XuxuGood/cdn@master/blogImages/resume/resumeBg.jpg)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="folding-2"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/XuxuGood/cdn@master/blogImages/resume/resumeBg.jpg)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line">- haha</span><br><span class="line">- hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="folding-3"><details><summary><p>查看图片测试</p></summary><div class="content"><p><img src="/images/lazy.gif" data-original="https://cdn.jsdelivr.net/gh/XuxuGood/cdn@master/blogImages/resume/resumeBg.jpg" alt=""></p></div></details><details cyan open><summary><p>查看默认打开的折叠框</p></summary><div class="content"><p>这是一个默认打开的折叠框。</p></div></details><details green><summary><p>查看代码测试</p></summary><div class="content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看代码测试</span><br></pre></td></tr></table></figure></div></details><details yellow><summary><p>查看列表测试</p></summary><div class="content"><ul><li>haha</li><li>hehe</li></ul></div></details><details red><summary><p>查看嵌套测试</p></summary><div class="content"><details blue><summary><p>查看嵌套测试2</p></summary><div class="content"><details><summary><p>查看嵌套测试3</p></summary><div class="content"><p>hahaha</p></div></details></div></details></div></details></div></div></div>]]></content>
  </entry>
</search>
