<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL</title>
    <url>/posts/b220/</url>
    <content><![CDATA[<h3 id="STL是什么"><a href="#STL是什么" class="headerlink" title="STL是什么"></a>STL是什么</h3><p>STL是建立在模板函数和类模板基础之上的功能强大的库，包括：<br>    —— 1）常用算法函数（如统计、排序、查找等）<br>    —— 2）容器</p>
<p>​    容器：存放数据的数据结构，例如数组、队列、栈、链表、树、图等，分为：<br>​        ——顺序容器：是指数据逻辑上、物理上都是按顺序存放的。 </p>
<p>​                常见的有：vector、queue、stack、deque。 </p>
<p>​        ——关联容器：存放的数据逻辑上有一定关联，但不一定是按顺序存放的 </p>
<p>​                常见的有set、multiset、map、multimap</p>
<p>​    迭代器(iterator):类似于C++中的指针，你可以把它看作是容器的数据存取员，通过它可以依次存取容器中的元素。不同的容器需要不同的迭代器，但这些迭代器的使用方法却类似。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="定义及简单变量类型数组排序"><a href="#定义及简单变量类型数组排序" class="headerlink" title="定义及简单变量类型数组排序"></a>定义及简单变量类型数组排序</h4><p>​    我们学过选择排序、冒泡排序、插入排序等各种排序算法，其实STL给我们提 供了排序函数sort，我们可以直接使用它！例如： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],n; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i]; <span class="comment">//需要排序，可以直接调用STL排序函数 </span></span><br><span class="line">sort(a,a+n); <span class="comment">//将a数组下标[0,n)区间元素（左闭右开）排序，默认按从小到大顺序排列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>​    sort是STL里的一个排序函数，包含在<algorithm>头文件中，它是利用快速 排序算法实现并进行优化的，具有非常高的效率，其时间复杂度为O(nlogn) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line"><span class="comment">//greater&lt;int&gt;()表示C++内置类型从大到小排序，尖括号里面int表示数组元素的数据类型</span></span><br><span class="line"><span class="comment">//如果是其他类型，就写相应的变量类型,如double等</span></span><br><span class="line"><span class="comment">//相对应还有less&lt;int&gt;()表示从小到大排序，这是系统默认的，可以省略。同样也可以使用函数来代替</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;<span class="comment">//降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(x,x+n,cmp);</span><br></pre></td></tr></table></figure>
<h4 id="sort对结构体排序"><a href="#sort对结构体排序" class="headerlink" title="sort对结构体排序"></a>sort对结构体排序</h4><p>​    sort除了对简单变量类型数组进行排序外，还可以对自定义的结构体数组进行排序。 </p>
<p>​    只是要提供结构体比较大小的函数，因为C++不知道自定义的结构体变量 谁大谁小。我们可以通过在结构体内添加比较大小的函数来实现！</p>
<h5 id="结构体成员函数介绍"><a href="#结构体成员函数介绍" class="headerlink" title="结构体成员函数介绍"></a>结构体成员函数介绍</h5><p>​    结构体内其实除了定义“成员变量” ，将这些成员变量组合在一起之外，它的功 能非常强大，还可以在结构体内定义函数，我们称其为“成员函数”。</p>
<p>​    成员函数主要完成跟结构体相关的功能，它可以直接调用结构体的成员变量，还 可以通过形参接受调用者传递进来的参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="built_in">string</span> Name; </span><br><span class="line">    <span class="keyword">int</span> Chinese,Math,English,sum; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span></span>&#123; </span><br><span class="line">        sum=Chinese+Math+English; </span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Student stu; </span><br><span class="line">    stu.Chinese=<span class="number">120</span>; </span><br><span class="line">    stu.Math=<span class="number">130</span>; </span><br><span class="line">    stu.English=<span class="number">90</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu.GetSum()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;输出 <span class="number">340</span></span><br></pre></td></tr></table></figure>
<h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p>​    为了完成结构体比较大小的功能，我们可以在结构体里面定义一个比较大小的函数 。因为STL提供的算法函数、容器一般是调用小于运算符比较大小，所以我们这里重载 小于运算符，这样结构体就可以直接用小于运算符比较大小了。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; <span class="comment">//重载&lt;运算符 </span></span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//operator	相当于函数名，固定格式，照样子写即可</span></span><br><span class="line"><span class="comment">//const &amp;a	表示形参是常变量，函数中不允许修改形参</span></span><br><span class="line"><span class="comment">//后一个const	表示该函数是常函数，不允 许修改结构体成员变量的值</span></span><br></pre></td></tr></table></figure>
<h5 id="运算符重载函数的调用"><a href="#运算符重载函数的调用" class="headerlink" title="运算符重载函数的调用"></a>运算符重载函数的调用</h5><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...<span class="comment">//结构体与上文一样</span></span><br><span class="line"></span><br><span class="line">node a,b; </span><br><span class="line">a.x=<span class="number">12</span>;</span><br><span class="line">a.y=<span class="number">3</span>; </span><br><span class="line">b.x=<span class="number">8</span>;</span><br><span class="line">b.y=<span class="number">9</span>; </span><br><span class="line"><span class="keyword">if</span>(a&lt;b)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&lt;b"</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&gt;=b"</span>; </span><br><span class="line">&gt;&gt;输出 <span class="string">"a&gt;=b"</span></span><br></pre></td></tr></table></figure>
<p>​    重载运算符我们可以把它看作是一类特殊的成员函数,a&lt;b本质是a.operator&lt;(b)，这里小于运算符是a的成员函数。所以重载运算符时传递的参数 只有一个。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//从小到大排</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">node p;</span><br><span class="line">sort(p,p+n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样也可以写函数排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">sort(p, p+n, cmp);</span><br></pre></td></tr></table></figure>
<p>补充: 初始化成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">double</span> x,y; </span><br><span class="line">    node(<span class="keyword">int</span> _x=<span class="number">0</span>,<span class="keyword">int</span> _y=<span class="number">0</span>):x(_x),y(_y)&#123;&#125; <span class="comment">//构造函数，完成成员变量初始化 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h4><p>​    vector是一种顺序容器，可以把它看作数组，是长度可变的动态数组。它的 储存空间根据存入数据多少自动分配，包含在<vector>头文件中。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;a; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;a; <span class="built_in">vector</span>&lt;Node&gt;a;<span class="comment">//Node为自定义的结构体 </span></span><br><span class="line"><span class="comment">//定义时初始化： </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);<span class="comment">//定义初始大小为10个元素的vector，初始值为0 </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>,<span class="number">2</span>);<span class="comment">//定义时给定大小为10，每个元素初始化为2 </span></span><br><span class="line"><span class="comment">//定义时用数组初始化： </span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">32</span>&#125;; 		</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b+<span class="number">1</span>,b+<span class="number">8</span>);<span class="comment">//用数组初始化，参数为迭代器，数组元素就是其地址 </span></span><br><span class="line"><span class="comment">//vector数组： </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">100</span>];<span class="comment">//vector数组，相当于二维数组 </span></span><br><span class="line"><span class="comment">//特别注意：</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>)和<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">10</span>]的区别</span><br></pre></td></tr></table></figure>
<h4 id="vector的引用"><a href="#vector的引用" class="headerlink" title="vector的引用"></a>vector的引用</h4><h5 id="下标-访问"><a href="#下标-访问" class="headerlink" title="下标[]访问"></a>下标[]访问</h5><p>略</p>
<h5 id="迭代器访问"><a href="#迭代器访问" class="headerlink" title="迭代器访问"></a>迭代器访问</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ::iterator it;  <span class="comment">//定义一个可以访问整型的vector的迭代器。 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a; </span><br><span class="line">............................. </span><br><span class="line"><span class="keyword">for</span>( it=a.<span class="built_in">begin</span>(); it!=a.<span class="built_in">end</span>();  it++ ) 		<span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>​    a.begin()返回指向第一个元素的迭代器；a.end()返回指向最后一个元素 下一个元素位置的迭代器（左闭右开）；<br>​    it!=a.end(); 为结束条件，迭代器一般不比较大小，关联容器的迭代器不 能比较大小，只能判断是否相等；迭代器相当于指针，对于简单变量类型 *it就是 迭代器指向的数据元素的值。</p>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ol>
<li>push_back()   在vector的最后添加一个数据元素，复杂度O(1)</li>
<li>pop_back()   删除最后一个数据元素.复杂度O(1) </li>
<li>begin ()     返回指向容器第一个元素的迭代器 .例如：it=a.begin();</li>
<li>end ()    返回指向容器尾端的迭代器.例如：it=a.end();</li>
<li>size ()     返回vector中数据元素的个数, 复杂度O(1).<br> 例如：for(int i=0; i&lt;a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;” “;</li>
<li>resize (n)   重设容器数据元素为n个，它改变size()的返回值.如果n大于当前元素个数，则新增元素用默认值初始化，已有的元素不受影响. 如果n比当前数据元素个数小，则多余的舍弃，仅改变size()返回值</li>
<li>erase    删除;可以删除单个数据元素，也可以删除一个左闭右开区间内的元素<br>例如：c.erase (pos);     //删除迭代器pos指向位置的元素 c.erase(bg,ed); // 删除迭代器[bg,ed)区间的数据 </li>
<li>clear ()         清空当前的vector，将size()归零，复杂度O(1).</li>
<li>rbegin()       返回指向最后一个元素的迭代器，用于逆向访问容器，这时要定义逆向迭代器，例如：vector<int>::reverse_iterator it;</li>
<li>rend()          返回指向第一个元素前一个位置的迭代器，逆向访问的结束位置</li>
<li>empty()     判断容器是否为空,若为空返回true，否则返回false</li>
<li>insert ()     插入一个元素。 vector采用分块储存技术，时间复杂度O(log(size())<br>例如：c.insert(pos,elem); // 在迭代器pos指向元素前面插入elem.<br>c.insert(pos,ncount,elem);//在迭代器pos前插入ncount个elem<br>c.insert(pos,first,end);//在迭代器pos前插入区间[first,end)的元素，first和end也是迭代器，表示的区间是左闭右开。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL选讲</title>
    <url>/posts/a220/</url>
    <content><![CDATA[<h3 id="STL是什么"><a href="#STL是什么" class="headerlink" title="STL是什么"></a>STL是什么</h3><p>STL是建立在模板函数和类模板基础之上的功能强大的库，包括：<br>    —— 1）常用算法函数（如统计、排序、查找等）<br>    —— 2）容器</p>
<p>​    容器：存放数据的数据结构，例如数组、队列、栈、链表、树、图等，分为：<br>​        ——顺序容器：是指数据逻辑上、物理上都是按顺序存放的。 </p>
<p>​                常见的有：vector、queue、stack、deque。 </p>
<p>​        ——关联容器：存放的数据逻辑上有一定关联，但不一定是按顺序存放的 </p>
<p>​                常见的有set、multiset、map、multimap</p>
<p>​    迭代器(iterator):类似于C++中的指针，你可以把它看作是容器的数据存取员，通过它可以依次存取容器中的元素。不同的容器需要不同的迭代器，但这些迭代器的使用方法却类似。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="定义及简单变量类型数组排序"><a href="#定义及简单变量类型数组排序" class="headerlink" title="定义及简单变量类型数组排序"></a>定义及简单变量类型数组排序</h4><p>​    我们学过选择排序、冒泡排序、插入排序等各种排序算法，其实STL给我们提 供了排序函数sort，我们可以直接使用它！例如： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],n; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i]; <span class="comment">//需要排序，可以直接调用STL排序函数 </span></span><br><span class="line">sort(a,a+n); <span class="comment">//将a数组下标[0,n)区间元素（左闭右开）排序，默认按从小到大顺序排列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>​    sort是STL里的一个排序函数，包含在<algorithm>头文件中，它是利用快速 排序算法实现并进行优化的，具有非常高的效率，其时间复杂度为O(nlogn) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line"><span class="comment">//greater&lt;int&gt;()表示C++内置类型从大到小排序，尖括号里面int表示数组元素的数据类型</span></span><br><span class="line"><span class="comment">//如果是其他类型，就写相应的变量类型,如double等</span></span><br><span class="line"><span class="comment">//相对应还有less&lt;int&gt;()表示从小到大排序，这是系统默认的，可以省略。同样也可以使用函数来代替</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;<span class="comment">//降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(x,x+n,cmp);</span><br></pre></td></tr></table></figure>
<h4 id="sort对结构体排序"><a href="#sort对结构体排序" class="headerlink" title="sort对结构体排序"></a>sort对结构体排序</h4><p>​    sort除了对简单变量类型数组进行排序外，还可以对自定义的结构体数组进行排序。 </p>
<p>​    只是要提供结构体比较大小的函数，因为C++不知道自定义的结构体变量 谁大谁小。我们可以通过在结构体内添加比较大小的函数来实现！</p>
<h5 id="结构体成员函数介绍"><a href="#结构体成员函数介绍" class="headerlink" title="结构体成员函数介绍"></a>结构体成员函数介绍</h5><p>​    结构体内其实除了定义“成员变量” ，将这些成员变量组合在一起之外，它的功 能非常强大，还可以在结构体内定义函数，我们称其为“成员函数”。</p>
<p>​    成员函数主要完成跟结构体相关的功能，它可以直接调用结构体的成员变量，还 可以通过形参接受调用者传递进来的参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="built_in">string</span> Name; </span><br><span class="line">    <span class="keyword">int</span> Chinese,Math,English,sum; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span></span>&#123; </span><br><span class="line">        sum=Chinese+Math+English; </span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Student stu; </span><br><span class="line">    stu.Chinese=<span class="number">120</span>; </span><br><span class="line">    stu.Math=<span class="number">130</span>; </span><br><span class="line">    stu.English=<span class="number">90</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu.GetSum()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;输出 <span class="number">340</span></span><br></pre></td></tr></table></figure>
<h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p>​    为了完成结构体比较大小的功能，我们可以在结构体里面定义一个比较大小的函数 。因为STL提供的算法函数、容器一般是调用小于运算符比较大小，所以我们这里重载 小于运算符，这样结构体就可以直接用小于运算符比较大小了。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; <span class="comment">//重载&lt;运算符 </span></span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//operator	相当于函数名，固定格式，照样子写即可</span></span><br><span class="line"><span class="comment">//const &amp;a	表示形参是常变量，函数中不允许修改形参</span></span><br><span class="line"><span class="comment">//后一个const	表示该函数是常函数，不允 许修改结构体成员变量的值</span></span><br></pre></td></tr></table></figure>
<h5 id="运算符重载函数的调用"><a href="#运算符重载函数的调用" class="headerlink" title="运算符重载函数的调用"></a>运算符重载函数的调用</h5><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...<span class="comment">//结构体与上文一样</span></span><br><span class="line"></span><br><span class="line">node a,b; </span><br><span class="line">a.x=<span class="number">12</span>;</span><br><span class="line">a.y=<span class="number">3</span>; </span><br><span class="line">b.x=<span class="number">8</span>;</span><br><span class="line">b.y=<span class="number">9</span>; </span><br><span class="line"><span class="keyword">if</span>(a&lt;b)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&lt;b"</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a&gt;=b"</span>; </span><br><span class="line">&gt;&gt;输出 <span class="string">"a&gt;=b"</span></span><br></pre></td></tr></table></figure>
<p>​    重载运算符我们可以把它看作是一类特殊的成员函数,a&lt;b本质是a.operator&lt;(b)，这里小于运算符是a的成员函数。所以重载运算符时传递的参数 只有一个。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node <span class="keyword">const</span> &amp;a)<span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//从小到大排</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">node p;</span><br><span class="line">sort(p,p+n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样也可以写函数排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">sort(p, p+n, cmp);</span><br></pre></td></tr></table></figure>
<p>补充: 初始化成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">double</span> x,y; </span><br><span class="line">    node(<span class="keyword">int</span> _x=<span class="number">0</span>,<span class="keyword">int</span> _y=<span class="number">0</span>):x(_x),y(_y)&#123;&#125; <span class="comment">//构造函数，完成成员变量初始化 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h4><p>​    vector是一种顺序容器，可以把它看作数组，是长度可变的动态数组。它的 储存空间根据存入数据多少自动分配，包含在<vector>头文件中。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;a; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;a; <span class="built_in">vector</span>&lt;Node&gt;a;<span class="comment">//Node为自定义的结构体 </span></span><br><span class="line"><span class="comment">//定义时初始化： </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);<span class="comment">//定义初始大小为10个元素的vector，初始值为0 </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>,<span class="number">2</span>);<span class="comment">//定义时给定大小为10，每个元素初始化为2 </span></span><br><span class="line"><span class="comment">//定义时用数组初始化： </span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">32</span>&#125;; 		</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b+<span class="number">1</span>,b+<span class="number">8</span>);<span class="comment">//用数组初始化，参数为迭代器，数组元素就是其地址 </span></span><br><span class="line"><span class="comment">//vector数组： </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">100</span>];<span class="comment">//vector数组，相当于二维数组 </span></span><br><span class="line"><span class="comment">//特别注意：</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>)和<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">10</span>]的区别</span><br></pre></td></tr></table></figure>
<h4 id="vector的引用"><a href="#vector的引用" class="headerlink" title="vector的引用"></a>vector的引用</h4><h5 id="下标-访问"><a href="#下标-访问" class="headerlink" title="下标[]访问"></a>下标[]访问</h5><p>略</p>
<h5 id="迭代器访问"><a href="#迭代器访问" class="headerlink" title="迭代器访问"></a>迭代器访问</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ::iterator it;  <span class="comment">//定义一个可以访问整型的vector的迭代器。 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a; </span><br><span class="line">............................. </span><br><span class="line"><span class="keyword">for</span>( it=a.<span class="built_in">begin</span>(); it!=a.<span class="built_in">end</span>();  it++ ) 		<span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>​    a.begin()返回指向第一个元素的迭代器；a.end()返回指向最后一个元素 下一个元素位置的迭代器（左闭右开）；<br>​    it!=a.end(); 为结束条件，迭代器一般不比较大小，关联容器的迭代器不 能比较大小，只能判断是否相等；迭代器相当于指针，对于简单变量类型 *it就是 迭代器指向的数据元素的值。</p>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ol>
<li>push_back()   在vector的最后添加一个数据元素，复杂度O(1)</li>
<li>pop_back()   删除最后一个数据元素.复杂度O(1) </li>
<li>begin ()     返回指向容器第一个元素的迭代器 .例如：it=a.begin();</li>
<li>end ()    返回指向容器尾端的迭代器.例如：it=a.end();</li>
<li>size ()     返回vector中数据元素的个数, 复杂度O(1).<br> 例如：for(int i=0; i&lt;a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;” “;</li>
<li>resize (n)   重设容器数据元素为n个，它改变size()的返回值.如果n大于当前元素个数，则新增元素用默认值初始化，已有的元素不受影响. 如果n比当前数据元素个数小，则多余的舍弃，仅改变size()返回值</li>
<li>erase    删除;可以删除单个数据元素，也可以删除一个左闭右开区间内的元素<br>例如：c.erase (pos);     //删除迭代器pos指向位置的元素 c.erase(bg,ed); // 删除迭代器[bg,ed)区间的数据 </li>
<li>clear ()         清空当前的vector，将size()归零，复杂度O(1).</li>
<li>rbegin()       返回指向最后一个元素的迭代器，用于逆向访问容器，这时要定义逆向迭代器，例如：vector<int>::reverse_iterator it;</li>
<li>rend()          返回指向第一个元素前一个位置的迭代器，逆向访问的结束位置</li>
<li>empty()     判断容器是否为空,若为空返回true，否则返回false</li>
<li>insert ()     插入一个元素。 vector采用分块储存技术，时间复杂度O(log(size())<br>例如：c.insert(pos,elem); // 在迭代器pos指向元素前面插入elem.<br>c.insert(pos,ncount,elem);//在迭代器pos前插入ncount个elem<br>c.insert(pos,first,end);//在迭代器pos前插入区间[first,end)的元素，first和end也是迭代器，表示的区间是左闭右开。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>整除</title>
    <url>/posts/62599/</url>
    <content><![CDATA[<h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><h4 id="整除的定义"><a href="#整除的定义" class="headerlink" title="整除的定义"></a>整除的定义</h4><p>​    对任给的两个整数<script type="math/tex">a,b(a\ne 0)</script>,如果存在整数<script type="math/tex">q</script>,使得<script type="math/tex">b=aq</script>,那么称<script type="math/tex">b</script>能被<script type="math/tex">a</script>整除,(或称<script type="math/tex">a</script>能整除<script type="math/tex">b</script>),记作<script type="math/tex">a\mid b</script>.否则,称<script type="math/tex">b</script>不能被<script type="math/tex">a</script>整除,记作<script type="math/tex">a \nmid b</script>  </p>
<p>​    如果<script type="math/tex">a\mid b</script>,那么称<script type="math/tex">a</script>为<script type="math/tex">b</script>的因数,<script type="math/tex">b</script>为<script type="math/tex">a</script>的倍数.</p>
<h4 id="整除的基本性质"><a href="#整除的基本性质" class="headerlink" title="整除的基本性质"></a>整除的基本性质</h4><ul>
<li><p>​    若<script type="math/tex">a\mid b,b\mid c</script>,那么<script type="math/tex">a\mid c</script>.这表明整除具有传递性.</p>
</li>
<li><p>​     如果<script type="math/tex">a\mid b</script>,那么<script type="math/tex">a\mid (-b)</script>,反过来也成立;进一步,如果<script type="math/tex">a\mid b</script>,那么<script type="math/tex">(-a)\mid b</script>,反过来也成立.</p>
<p>​     因此,我们经常只讨论正整数之间的整除关系.</p>
</li>
<li><p>​      若<script type="math/tex">a\mid b,a\mid c</script>,则对任意整数<script type="math/tex">x,y</script>,都有<script type="math/tex">a\mid bx+cy</script>.(即<script type="math/tex">a</script>能整除<script type="math/tex">b,c</script>的任意一个”线性组合”)</p>
</li>
</ul>
<h4 id="能被整除的数的特征"><a href="#能被整除的数的特征" class="headerlink" title="能被整除的数的特征"></a>能被整除的数的特征</h4><ol>
<li>1与0的特性<br> 1是任何整数的约数，即对于任何整数a，总有1|a.<br> 0是任何非零整数的倍数，a≠0,a为整数，则a|0.</li>
<li>能被2整除的数的特征<br> 若一个整数的末位是0、2、4、6或8，则这个数能被2整除.</li>
<li>能被3整除的数的特征<br> 1.若一个整数的数字和能被3整除，则这个整数能被3整除;<br> 2.由相同的数字组成的三位数、六位数、九位数……这些数字能被3整除.如111被3整除.</li>
<li>能被4整除的数的特征<br> 若一个整数的末尾两位数能被4整除，则这个数能被4整除.</li>
<li>能被5整除的数的特征<br> 若一个整数的末位是0或5，则这个数能被5整除</li>
<li>能被11整除的数的特征<br> 若一个整数的奇位数字之和与偶位数字之和的差能被11整除，则这个数能被11整除.</li>
</ol>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>整除</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类知乎卡片超链接测试"><a href="#类知乎卡片超链接测试" class="headerlink" title="类知乎卡片超链接测试"></a>类知乎卡片超链接测试</h4><p><a href="/photos/" class="LinkCard">我的相册——时光留影</a></p>
<hr>
<h4 id="APlayer音乐播放器测试"><a href="#APlayer音乐播放器测试" class="headerlink" title="APlayer音乐播放器测试"></a>APlayer音乐播放器测试</h4><link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

<hr>
<h4 id="DPlayer视频播放器测试"><a href="#DPlayer视频播放器测试" class="headerlink" title="DPlayer视频播放器测试"></a>DPlayer视频播放器测试</h4><div id="dplayer"></div>
<script src="/dist/DPlayer.min.js"></script>
<script type="text/javascript" src="/dist/video.js"></script>

<hr>
<h4 id="B站视频播放器测试"><a href="#B站视频播放器测试" class="headerlink" title="B站视频播放器测试"></a>B站视频播放器测试</h4><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=455914516&bvid=BV1Z5411p7Ct&cid=204031142&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<hr>
<h4 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h4><p><span id="inline-blue"> 站点配置文件 </span><br><span id="inline-purple"> 主题配置文件 </span><br><span id="inline-yellow"> 站点配置文件 </span><br><span id="inline-green"> 主题配置文件 </span></p>
<hr>
<h4 id="下载样式"><a href="#下载样式" class="headerlink" title="下载样式"></a>下载样式</h4><p><a id="download" href="https://git-scm.com/download/win" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span> </a></p>
<h4 id="地球"><a href="#地球" class="headerlink" title="地球"></a>地球</h4><script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5xgme3vd9ru&amp;m=6&amp;c=007eff&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"></script>]]></content>
  </entry>
</search>
